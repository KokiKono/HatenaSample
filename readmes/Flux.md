# Fluxアプリケーション詳細
![Image1](https://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png "単一データフロー1")  
単方向データフローはFluxパターンの中心であり、上の図に沿ってFluxアプリケーションを組みましょう。
それぞれのノードは独立した入出力インターフェースを含単純なオブジェクトであるべきです。  
![Imge2](https://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png "ユーザーアクション")  
WebでもNativeでもデータ更新が行われるのは、ほとんどがユーザーの操作から発火されます。  
そのデータ更新は全てにおいて、ディスパッチャを介して、ストアにコールバックを呼び出して、ストアはデータ保守状態に関連するメソッドを呼び出します。  
ストアがデータ更新を行ったあとはビューに変更イベントを送信します。  
コントローラービュー（今回はEvents)などはsetState()メソッドを呼び出して、コンポーネントを再レンダリングします。  
このような構造により、より機能的なリアクティブプリグラムを構築できます。  
逆に双方向のデータフローでは様々なオブジェクトが変更され、そのオブジェクトを変更するトリガーが増加するにつれて  
１アクションの結果が予想できないようになっていきます。  

Fluxを用いたファイル構成を以下のようになります。  
```
    App/  
    ├ Actions/  
    ├ Stores/  
    ├ Dispatcher/
    ├ Views/  
    └ app.js  
```
## Dsipatcher
ディスパッチャは、Fluxアプリケーションのすべてのデータフローを管理する中心的なハブです。これは本質的にはストアへのコールバックのレジストリであり、独自の実際のインテリジェンスはなく、アクションをストアに配布するための単純なメカニズムです。各ストアは自身を登録し、コールバックを提供します。アクション作成者がディスパッチャに新しいアクションを提供すると、アプリケーション内のすべてのストアがレジストリ内のコールバックを介してアクションを受け取ります。

アプリケーションが大きくなると、ディスパッチャは特定の順序で登録されたコールバックを呼び出すことによってストア間の依存関係を管理するために使用できるため、より重要になります。ストアは、他のストアが更新を完了するのを宣言的に待ってから、それに応じて更新することができます。

今回はおまじない的なファイルになると思う。  
[HatenaでのDispatcherファイル](https://github.com/KokiKono/HatenaSample/blob/turorial/App/Dispatcher/dispatcher.js)
## Stores
ストアには、アプリケーションの状態とロジックが含まれます。
MVCモデルのモデルといくつか似てますが、多くのオブジェクトを管理しています。
ORMのような単一なデータレコードとは違います。  
[HatenaでのToDoStore](https://github.com/KokiKono/HatenaSample/blob/turorial/App/Stores/ToDoStore.js)  
HatenaSampleでは単一のデータのみを管理していますが、実際はToDoに関する情報を管理できます。  
## Views and Controller-Views
React,React Nativeでは必要かつ構成可能なビューレイアを自由に再レンダリングできます。
ストアからイベントを受け取ると、ストアのgetterを使用して必要な新しいデータを取得し、setStateなどのメソッドを実行させ、Viewの更新を促します。  
[HatenaでのToDoList](https://github.com/KokiKono/HatenaSample/blob/turorial/App/Views/ToDoList.js)  
## Actions
ディスパッチャは、ストアへのディスパッチをトリガし、データのペイロードを含めるためのメソッドを公開します。これをアクションと呼びます。アクションの作成は、アクションをディスパッチャに送信するセマンティックヘルパーメソッドにラップすることができます。たとえば、予定表アプリケーションでToDo項目のテキストを変更したい場合があります。 TodoActionsモジュールのupdateText（todoId、newText）のような関数シグネチャを持つアクションを作成します。このメソッドは、ビューのイベントハンドラ内から呼び出すことができるため、ユーザーの操作に応じて呼び出すことができます。このアクション作成メソッドは、アクションをタイプに追加するので、アクションがストア内で解釈されるときに、適切に応答することができます。

アクションは、サーバーなどの他の場所から発生することもあります。これは、例えば、データ初期化中に起こる。また、サーバーがエラーコードを返したとき、またはサーバーにアプリケーションに提供する更新があるときに発生する可能性があります。

[HatenaでのTodoActions](https://github.com/KokiKono/HatenaSample/tree/turorial/App/Actions)
